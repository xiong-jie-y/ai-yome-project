# Mediapipeのフレームワークとしての特徴
mediapipeは高性能な機械学習モデルが簡単に使えるライブラリとしてよく取り上げられるライブラリです。ただ、mediapipeはロボットやアプリケーションにとっての認識パイプラインを組み立てるためのフレームワークとして見ると面白くて、特に複数人での認識パイプラインの開発を大きく効率化するポテンシャルを持っていると思います。この章では、mediapipeのフレームワークとしての側面を見てみます。

## フローチャートを組み立てるような感覚で認識パイプラインを作る
Mediapipeでは、Calculatorという単位で処理がたくさん用意されていて、
このCalculatorを組み合わせて、データを処理するプログラムをフローで書くことができます。
CalculatorはC++で記述されていて、ある名前、ある型のデータを受け取り、ある型のデータを有る名前として出力する任意の処理です。関数やクラスとは異なり、実行時に１：１で繋がっているわけではなく、出力を$n>=1$のCalculatorに渡せます。つまり、どちらかというとPub/SubのようなアーキテクチャでCalculatorを組み合わせてプログラムを構築するような感じです。　

このグラフで書く仕組みは、どのようなプログラムにも適しているわけではなく、
60Hzとか90Hzとか一定周期ではいってくるデータを扱うようなもの（語弊があるかもだが、リアルタイム処理）に適しているように思います。
理由としては、mediapipeでは、Calculatorの処理はスレッドに割り当てられていて、
リアルタイムに動作させられるようにスケジューリングされていること、
データ同期やフレームドロップの仕組みが作りやすくなっていること、などが挙げられます。

OSSや企業内での可能性として、
Calculatorを共有する仕組みと、グラフ書いてビルドできるクラウド環境があれば、
企業やOSSで他人が作ったCalculatorやGraphを組み合わせて、
素早く認識パイプラインを作る。といったことが可能になりそうです。
Calculatorもグラフも認識パイプラインに特化していて、
githubでコードリポジトリを共有することよりも、１段階上の共有になりそうです。

また、ロボットのコントローラーなどもCalculatorとして実装して、この枠組みの中で作るようなこともできますがそこまでやる人がここまでなるイメージはない。なぜなら、ROSのコミュニティやROSパッケージの多様性、量、品質に今から追いつけるとは思えないし、mediapipeへの移行メリットも少ないからです。

!!! todo
    * ストリーミング処理は実装できるか？[ペーパーで関連したものとして上げられてリウ。](https://arxiv.org/pdf/1906.08172.pdf)

## ROSとmediapipeの違い
大きな違いは、ノード間の協調方法にあり、ROSでは、実行の単位であるノードがプロセスであり、
Mediapipeでは実行の単位であるCalculatorがスレッドであるということです。
この２つの違いから次のような相違点が出てきます。

まずは、ノード間の通信の遅延です。
ROSでは、特にシリアライズのオーバーヘッドにプラスして、ROS1では、HTTP＋XMLRPCのオーバーヘッドも追加されるため、全てのノードが同じPCで動作していても、ms単位で遅延が載ってくると想像でき、90FPSとかが要求されるアプリとか、計算リソースが貧弱なコンピュータ上で動かすなら、
シリアライズや通信がないmediapipeが適しているように思えます。
[mediapipeのペーパー](https://arxiv.org/pdf/1906.08172.pdf)にもそのように書かれています。ROS2の設計時の[DDSの調査ドキュメント](https://design.ros2.org/articles/ros_on_dds.html)にはROS1でもnodeletsを使ってshared_ptrをプロセス間でやり取りすることで高速なデータやり取りができるようです。

次にノードの分散処理が可能かどうかという違いがあります。
Mediapipeは、Calculatorは全てスレッドであるため、
フレームワークとしてのサポートはありません。
分散処理をするには、ユーザが明示的に他プロセスと通信する必要があります。
一方で、ROSはノードがプロセスであり、プロセス間の通信はROSがやってくれます。

おそらく、ROSのほうがMediapipeよりも複雑なシステムに適しています。
で、Mediapipeは小型のデバイスやリアルタイム処理が必要なアプリに
適していると思います。また、ノード間のデータのやり取りのオーバーヘッドが同じプログラム内の関数レベルなので、ノードの粒度をROSよりも小さくできます。

!!! todo
    * もう少し詳細に理由を書く。

## OpenCV Graph APIとの違い
Graph APIは画像処理フローをグラフで書いて、
そのグラフを元にopencv側が自動的に最適化してくれるような仕組みのようです。
ただ、全ての処理をGraph APIで書けることは保証されておらず、使いどころが難しそうです。

## Calculatorをどう実装して共有するか?
CalculatorとGraphが増えていくと、mediapipeで作れるものが格段に増える。これらをどのように共有するか考える。
ここでは例えば、3D認識やARの機能をmediapipeを使って、mediapipeのリポジトリとは独立した形でメンテ・提供する方法を考える。SLAMの実装も検討する。

例えば、RGBDカメラを使って、ある物体の3D Bounding Boxを検知してトラッキングするFlowを作るとしよう。

* 3D Bounding Boxのデータ構造(protobuf message?)
* Calculator (3D Bounding Box検知、トラッキング)
* グラフ
* グラフ実行スクリプト

の４つが必要になります。これらの４つを作り、ビルドの依存関係を書いていくことになります。
リポジトリとして、mediapipeを外部パッケージとしてもつリポジトリを作り、
それぞれから、mediapipeのCalculatorなどにアクセスすれば出来ると思います。

## その他の特徴・改善点 (WIP)
### デバッグ・小さい単位でのテストを容易にしたい
* １フレームごとのテストを容易にしたい。
  * → カメラ、ジャイロなどのセンサデータ保存。再生の仕組み。
* 

### Calculator
* 入力と出力の名前と型がプログラムにより定義される。

### 他のプログラミング言語でCalculatorを実装可能にしたい
ROSではプログラミング言語の選択は自由だが、mediapipeでは基本C++でかく、
Rustなどdynamic library化できる言語であれば使えるはずなので、模索したい。
特にRustでの実装を実現したい。Pythonもプロトタイプ実装に役立つはずです。

### ROSへの組み込み
* ROSの他のコンポーネントの連携検討

!!! todo
    * ROSの他のコンポーネントの連携などユースケースを探す
    * ROSにmediapipeと似たフレームワークがないか調べる


* 含まれている機械学習モデルの情報が実装に必要なレベルで用意されている
  * Calculatorでラップされているが、たまに足りない情報があり、Subgraph, Calculatorコードを読む必要がある