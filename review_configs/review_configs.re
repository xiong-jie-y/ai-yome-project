
= mediapipeフレームワークの特徴

== 基礎知識

=== スレッドとプロセスの扱いの違い


iOS, Android, 


== 概要と解決する課題


@<href>{https://arxiv.org/pdf/1906.08172.pdf,mediapipe}はPerceptionパイプラインを

 * 複数のプラットフォームやデバイスで動くアプリを
 * iterativeに作っていけるようなフレームワーク



です。アプリケーションを作る流れとしては、作者は、

 1. 機械学習モデルの選定やアルゴリズムの開発
 1. プロトタイプやデモの構築
 1. 品質とリソース消費のバランスを取り
 1. 問題を特定して解決する



こととして上げています。私は、アプリとしてリリースすることが目標であれば、
1,3,4に時間がかかると思っています。
1はtfliteモデルやCalculatorの提供によって、
3はCalculatorに処理、グラフにフローを書くことによる設計上の分離により解決し、4はprofilingやvisualizerにより緩和されています。



1に関してはモデルやアルゴリズムをmediapipe上で実装する手間は多少増えます。（CalculatorのI/F対応と、モデルの設定）
3,4はいかにCalculatorの品質とマルチプラットフォーム対応がしっかりしているかという点に左右されます。



個人的にはmediapipeを使ってみた感じ、4の工数はとんとんで、提供されているモデルやアルゴを使うことによる、1工数の削減と3が大きな利点かと思います。4の工数に関しては、Calculatorやサブグラフのコードを辿りにくいのが原因で、扱うCalculatorやSubgraphに詳しくなると変わってくる気もします。
（とにかくアルゴリズムの変更がやりやすい）



ただ、mediapipeは普通のアプリにPerceptionPipelineを追加する以外にもロボットの認識パイプラインの１プロセスとして使うことも検討できそうです。他にも複数人での認識パイプラインの開発を大きく効率化するポテンシャルを持っていると思います。



6年間様々なアプリで成果を上げてきたとのことだが、KPIとか測定したデータは公開されていなかった。ただ、@<href>{https://arxiv.org/pdf/1906.08172.pdf,成功の鍵となったのは、再利用可能なCalculatorとグラフであると述べられていた。}



この章では、そういったmediapipeのフレームワークとしての側面を見てみます。


== 利用者別のメリット

=== 個人で利用する場合
 * メリット
 ** トラッキングや検出モデルのCalculatorがあり、それらを組み合わせて高速にデモやアプリを作れる可能性がある
 ** また、フレームワークに用意されているCalculatorは、マルチプラットフォームかつ、CPU、GPU両方対応のものが多くて、多くのデバイスで動くものが作れる。
 ** CalculatorはThreadPoolで動き、Threadpoolの大きさはデバイスごとに設定されていて、その設定の範囲でベストパフォーンスが出せる。パフォーマンスを出すためのコードを書かなくていいかもしれない。
 * デメリット
 ** CalculatorはC++でしかかけないので、他の言語で書かれたコードをC++で書き直す必要がある（-2)
 ** CalculatorのI/F定義を書く必要がある(-1)



なので、普段からC++でロジックを書いている人なら、mediapipeへの移行コストはそこまで大きくなく、恩恵の方が多くなる可能性がありますが、Pythonで書いていて、速度にも不満がない場合は、特に恩恵はないと思います。



今後の、コミュニティの成長やmediapipeへのCalculatorのコミットにより、
使いやすくなると思います。ただ、公式mediapipeは、メンテナンスするコード量を減らすために、
公式calculatorは絞るはずなので、third_partyの活躍が期待されます。(後述)



!!! todo
    * パフォーマンスチューニングがどの程度必要か体験しておきたい


=== 企業で利用する場合

== フローチャートを組み立てるような感覚で認識パイプラインを作る


Mediapipeでは、Calculatorという単位で処理がたくさん用意されていて、
このCalculatorを組み合わせて、データを処理するプログラムをフローで書くことができます。
CalculatorはC++で記述されていて、ある名前、ある型のデータを受け取り、ある型のデータを有る名前として出力する任意の処理です。関数やクラスとは異なり、実行時に１：１で繋がっているわけではなrく、出力を$n>=1$のCalculatorに渡せます。つまり、どちらかというとPub/SubのようなアーキテクチャでCalculatoを組み合わせてプログラムを構築するような感じです。　



このグラフで書く仕組みは、どのようなプログラムにも適しているわけではなく、
60Hzとか90Hzとか一定周期ではいってくるデータを扱うようなもの（語弊があるかもだが、リアルタイム処理）に適しているように思います。
理由としては、mediapipeでは、Calculatorの処理はスレッドに割り当てられていて、
リアルタイムに動作させられるようにスケジューリングされていること、
データ同期やフレームドロップの仕組みが作りやすくなっていること、などが挙げられます。



OSSや企業内での可能性として、
Calculatorを共有する仕組みと、グラフ書いてビルドできるクラウド環境があれば、
企業やOSSで他人が作ったCalculatorやGraphを組み合わせて、
素早く認識パイプラインを作る。といったことが可能になりそうです。
Calculatorもグラフも認識パイプラインに特化していて、
githubでコードリポジトリを共有することよりも、１段階上の共有になりそうです。



また、ロボットのコントローラーなどもCalculatorとして実装して、この枠組みの中で作るようなこともできますがそこまでやる人がここまでなるイメージはない。なぜなら、ROSのコミュニティやROSパッケージの多様性、量、品質に今から追いつけるとは思えないし、mediapipeへの移行メリットも少ないからです。



!!! todo
    * ストリーミング処理は実装できるか？@<href>{https://arxiv.org/pdf/1906.08172.pdf,ペーパーで関連したものとして上げられてリウ。}


== Calculatorをどう実装して共有するか?


CalculatorとGraphが増えていくと、mediapipeで作れるものが格段に増える。これらをどのように共有するか考える。
ここでは例えば、3D認識やARの機能をmediapipeを使って、mediapipeのリポジトリとは独立した形でメンテ・提供する方法を考える。SLAMの実装も検討する。



例えば、RGBDカメラを使って、ある物体の3D Bounding Boxを検知してトラッキングするFlowを作るとしよう。

 * 3D Bounding Boxのデータ構造(protobuf message?)
 * Calculator (3D Bounding Box検知、トラッキング)
 * グラフ
 * グラフ実行スクリプト



の４つが必要になります。これらの４つを作り、ビルドの依存関係を書いていくことになります。
リポジトリとして、mediapipeを外部パッケージとしてもつリポジトリを作り、
それぞれから、mediapipeのCalculatorなどにアクセスすれば出来ると思います。


== フレームワークの性能上の意義


!!! todo
    * ThreadPoolあたりの実装と今後の可能性を調査


== その他の特徴・改善点 (WIP)

=== third_partyリポジトリの検討


OSSコミュニティやその他のアプリ開発者との協調案としては、
高品質かつ、マルチプラットフォームなCalculatorを豊富にメンテナンスするリポジトリがあれば、結構いろんな人が簡単にPerceptionPipelineを作れる。何らかの機械学習モデル提供リポジトリmodel_zooとかとシームレスに連携出来る仕組みやVisualizerが整えばかなり使いやすくなると思います。


=== デバッグ・小さい単位でのテストを容易にしたい
 * １フレームごとのテストを容易にしたい。
 ** → カメラ、ジャイロなどのセンサデータ保存。再生の仕組み。
 * 


=== Calculator
 * 入力と出力の名前と型がプログラムにより定義される。


=== 他のプログラミング言語でCalculatorを実装可能にしたい


ROSではプログラミング言語の選択は自由だが、mediapipeでは基本C++でかく、
Rustなどdynamic library化できる言語であれば使えるはずなので、模索したい。
特にRustでの実装を実現したい。Pythonもプロトタイプ実装に役立つはずです。


=== ROSへの組み込み
 * ROSの他のコンポーネントの連携検討



!!! todo
    * ROSの他のコンポーネントの連携などユースケースを探す
    * ROSにmediapipeと似たフレームワークがないか調べる

 * 含まれている機械学習モデルの情報が実装に必要なレベルで用意されている
 ** Calculatorでラップされているが、たまに足りない情報があり、Subgraph, Calculatorコードを読む必要がある


== その他のフレームワークとの比較

=== ROSとmediapipeの違い


大きな違いは、ノード間の協調方法にあり、ROSでは、実行の単位であるノードがプロセスであり、
Mediapipeでは実行の単位であるCalculatorがスレッドであるということです。
この２つの違いから次のような相違点が出てきます。



まずは、ノード間の通信の遅延です。
ROSでは、特にシリアライズのオーバーヘッドにプラスして、ROS1では、HTTP＋XMLRPCのオーバーヘッドも追加されるため、全てのノードが同じPCで動作していても、ms単位で遅延が載ってくると想像でき、90FPSとかが要求されるアプリとか、計算リソースが貧弱なコンピュータ上で動かすなら、
シリアライズや通信がないmediapipeが適しているように思えます。
@<href>{https://arxiv.org/pdf/1906.08172.pdf,mediapipeのペーパー}にもそのように書かれています。ROS2の設計時の@<href>{https://design.ros2.org/articles/ros_on_dds.html,DDSの調査ドキュメント}にはROS1でもnodeletsを使ってshared_ptrをプロセス間でやり取りすることで高速なデータやり取りができるようです。



次にノードの分散処理が可能かどうかという違いがあります。
Mediapipeは、Calculatorは全てスレッドであるため、
フレームワークとしてのサポートはありません。
分散処理をするには、ユーザが明示的に他プロセスと通信する必要があります。
一方で、ROSはノードがプロセスであり、プロセス間の通信はROSがやってくれます。



おそらく、ROSのほうがMediapipeよりも複雑なシステムに適しています。
で、Mediapipeは小型のデバイスやリアルタイム処理が必要なアプリに
適していると思います。また、ノード間のデータのやり取りのオーバーヘッドが同じプログラム内の関数レベルなので、ノードの粒度をROSよりも小さくできます。



!!! todo
    * もう少し詳細に理由を書く。


=== OpenCV Graph APIとの違い


Graph APIは画像処理フローをグラフで書いて、
そのグラフを元にopencv側が自動的に最適化してくれるような仕組みのようです。
ただ、全ての処理をGraph APIで書けることは保証されておらず、使いどころが難しそうです。

